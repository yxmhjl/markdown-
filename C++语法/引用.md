类变量是Page *pages_;分配内存时这样pages_ = new Page[pool_size_];引用的时候Page page = pages_[1]为什么不行

在C++中，如果你定义了一个指针Page *pages_;并且使用pages_ = new Page[pool_size_];为它分配了一块连续的内存空间来存储pool_size_个Page对象，那么你实际上是创建了一个动态数组。当你想要访问这个数组中的元素时，你可以通过索引的方式进行，例如pages_[1]。

但是，当你写Page page = pages_[1];时，这行代码实际上是在执行一个复制操作。具体来说，这里发生了以下几件事情：

数组访问：pages_[1]会访问到数组中第二个Page对象（因为数组索引是从0开始的）。
复制构造：然后，这个Page对象会被复制到一个新的局部变量page中。这意味着page是一个与pages_[1]具有相同值的新对象，而不是对原数组中对象的引用。
如果Page类有一个复制构造函数，并且这个复制构造函数没有正确实现，或者Page对象包含有指向动态分配内存的指针，那么这种直接复制可能会导致问题，比如浅复制带来的双重释放问题等。

如果你只是想获取对数组中某个对象的引用，而不是复制它，你应该这样做：

如果你想要一个常量引用，可以写成const Page& page = pages_[1];。
如果你需要一个非常量引用（即你可能需要修改这个对象），则可以写成Page& page = pages_[1];。
这两种方式都不会创建Page的新实例，而是直接引用pages_数组中的对象。这通常更加高效，尤其是在处理大型对象或复杂对象时。