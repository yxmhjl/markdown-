# c++ auto基本用法

auto的原理就是根据后面的值，来自己推测前面的类型是什么。

auto的作用就是为了简化变量初始化，如果这个变量有一个很长很长的初始化类型，就可以用auto代替。

注意点：
1.用auto声明的变量必须初始化（auto是根据后面的值来推测这个变量的类型，如果后面没有值，自然会报错）

2.函数和模板参数不能被声明为auto（原因同上）

3.因为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid

4.定义在一个auto序列的变量必须始终推导成同一类型

auto x1 = 5, x2 = 5.0, x3='r';  // This is too much....we cannot combine like this
示例：
std::vector<std::string> ve;
std::vector<std::string>::iterator it = ve.begin();
 我们可以用atuo来代替那个初始化类型：

auto it = ve.begin();
此外，如果是可用迭代器的对象的话，还可以这样操作：

int main(){
    vector<int>v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(3);
    for(auto i : v){
        cout<<i<<" ";
    }
    cout<<endl;
    return 0;
}
auto在这里就是简单的替换了int类型。

# C++中explicit的用法

C++提供了关键字explicit，可以阻止不应该允许的经过转换构造函数进行的隐式转换的发生,声明为explicit的构造函数不能在隐式转换中使用。

C++中， 一个参数的构造函数(或者除了第一个参数外其余参数都有默认值的多参构造函数)， 承担了两个角色。 

1 是个构造；2 是个默认且隐含的类型转换操作符。

所以， 有时候在我们写下如 AAA = XXX， 这样的代码， 且恰好XXX的类型正好是AAA单参数构造器的参数类型， 这时候编译器就自动调用这个构造器， 创建一个AAA的对象。

这样看起来好象很酷， 很方便。 但在某些情况下， 却违背了程序员的本意。 这时候就要在这个构造器前面加上explicit修饰， 指定这个构造器只能被明确的调用/使用， 不能作为类型转换操作符被隐含的使用。


解析：explicit构造函数是用来防止隐式转换的。请看下面的代码：

#include <iostream>
using namespace std;
class Test1
{
public :
	Test1(int num):n(num){}
private:
	int n;
};
class Test2
{
public :
	explicit Test2(int num):n(num){}
private:
	int n;
};

int main()
{
	Test1 t1 = 12;
	Test2 t2(13);
	Test2 t3 = 14;
		

return 0;

}

编译时，会指出 t3那一行error:无法从“int”转换为“Test2”。而t1却编译通过。注释掉t3那行，调试时，t1已被赋值成功。

注意：当类的声明和定义分别在两个文件中时，explicit只能写在在声明中，不能写在定义中。